import numpy as np
from scipy.stats import gamma, norm, expon
from collections import defaultdict

class SteelProductionLine:
    def __init__(self):

          # First workstation
          self.n = 20
          self.h1 = 800
          self.h2 = 200
          self.ci = 50
          self.cf = 3000
          self.cu = 100
          self.cr = 230
          self.cs = 0.01

          # Hammer degradation
          self.alpha_T1 = 1
          self.beta_T1 = 0.1
          self.alpha_T2 = 0.5
          self.beta_T2 = 0.12
          self.hammer_degradation = np.zeros(self.n)
          self.total_replaced_hammers = 0
          self.last_num_defective_hammers = 0

          # Production
          self.c1 = 1.0
          self.c2 = 0.8
          self.current_Pt = self.c1 * max(0, norm.rvs(loc=1.0, scale=0.1)) * 20
          self.production_pace = 'T1'

          # Maintenance parameters
          self.Tp = 4
          self.Tu = 1
          self.Ta_mean = 10

          self.last_pm_time = 0
          self.last_cm_time = 0
          self.cumulative_cm = 0
          self.first_ws_stopped = False
          self.second_ws_stopped = False

          # Second workstation
          self.demand_mean = 15
          self.demand_std = 1
          self.failure_rate = 1/336
          self.cm_duration_mean_ws2 = 3
          self.pm_duration_ws2 = 2
          self.WS2_age = 0
          self.lifetime = expon.rvs(scale=1/self.failure_rate)
          self.is_down = False
          self.current_rul = self.lifetime
          self.current_dt = norm.rvs(loc=self.demand_mean, scale=self.demand_std)
          self.unmet_demand_during_m = 0

          # Buffer
          self.buffer_capacity = 1000
          self.current_bt = 0

          # Initial state
          self.current_state_Pt, self.current_state_bt, self.current_state_dt = self.get_state(self.current_Pt, self.current_bt, self.current_dt)
          self.time = 0


    def get_production_rate(self):
        rho_t = max(0, norm.rvs(loc=1.0, scale=0.1))
        hammer_contributions = np.zeros(self.n)
        for i in range(self.n):
            if self.hammer_degradation[i] < 0.2:
                hammer_contributions[i] = 1.0
            elif self.hammer_degradation[i] < 0.3:
                hammer_contributions[i] = 0.8
            elif self.hammer_degradation[i] < 0.4:
                hammer_contributions[i] = 0.6
            else:
                hammer_contributions[i] = 0.0
        if self.production_pace == 'T1':
            Pt = self.c1 * rho_t * np.sum(hammer_contributions)
        else:
            Pt = self.c2 * rho_t * np.sum(hammer_contributions)
        return Pt


    def get_demand(self):
        #Generating demand for the second workstation
        if self.second_ws_stopped:
            return 0
        else:
            return norm.rvs(loc=self.demand_mean, scale=self.demand_std)

    def get_rul(self):
        rul = self.lifetime - self.WS2_age
        return rul

    def get_buffer_level(self, Pt, bt, dt):
        new_bt = bt + Pt - dt
        return max(0, min(new_bt, self.buffer_capacity))

    def get_unmet_demand(self, Pt, bt, dt):
        if dt > Pt + bt:
          return dt - Pt - bt
        else:
          return 0

    def get_production_pace(self, bt):
        if bt >= self.h1:
            self.production_pace = 'T2'
        elif bt <= self.h2:
            self.production_pace = 'T1'
        return self.production_pace

    def get_state(self, Pt, bt, dt):
          # State aggregation for pt
          if Pt >= 0.75 * self.c1 * self.n:
              Pt_state = 0
          elif Pt >= 0.5 * self.c1 * self.n:
              Pt_state = 1
          elif Pt >= 0.25 * self.c1 * self.n:
              Pt_state = 2
          else:
              Pt_state = 3

          # State aggregation for bt
          if bt >= 800:
              bt_state = 4
          elif bt >= 600:
              bt_state = 3
          elif bt >= 400:
              bt_state = 2
          elif bt >= 200:
              bt_state = 1
          else:
              bt_state = 0

          # State aggregation for dt (demand)
          if dt > 0:
              dt_state = 1
          else:
              dt_state = 0


          return Pt_state, bt_state, dt_state

    def update_hammer_degradation(self):
      if self.production_pace == 'T1':
          alpha = self.alpha_T1
          beta = self.beta_T1
      else:
          alpha = self.alpha_T2
          beta = self.beta_T2

      for i in range(self.n):
          degradation_increment = gamma.rvs(a=alpha, scale=beta)
          self.hammer_degradation[i] += degradation_increment
          if self.hammer_degradation[i] > 1.0:
              self.hammer_degradation[i] = 1.0

    def pm_perform_ws1_action1(self):
        self.last_num_defective_hammers = np.sum(self.hammer_degradation >= 0.2)
        if self.last_num_defective_hammers <= 3:
            replacement_cost = self.cr * 3
        else:
            replacement_cost = self.cr * self.last_num_defective_hammers
        maintenance_duration = self.Tp + self.last_num_defective_hammers * self.Tu
        self.hammer_degradation[self.hammer_degradation >= 0.2] = 0.0
        self.last_pm_time = self.time
        return maintenance_duration, replacement_cost


    def pm_perform_ws1(self):
        self.last_num_defective_hammers = np.sum(self.hammer_degradation >= 0.2)
        replacement_cost = self.cr * self.last_num_defective_hammers
        maintenance_duration = self.Tp + self.last_num_defective_hammers * self.Tu
        self.hammer_degradation[self.hammer_degradation >= 0.2] = 0.0
        self.last_pm_time = self.time
        return maintenance_duration, replacement_cost


    def cm_perform_ws1(self):
        self.last_num_defective_hammers = np.sum(self.hammer_degradation >= 0.2)
        replacement_cost = self.cr * self.last_num_defective_hammers
        maintenance_duration = self.Tp + self.last_num_defective_hammers * self.Tu + expon.rvs(scale=self.Ta_mean)
        self.hammer_degradation[self.hammer_degradation >= 0.2] = 0.0
        self.last_cm_time = self.time
        self.cumulative_cm += 1
        return maintenance_duration, replacement_cost


    def cm_perform_ws2(self):
        cm_duration = expon.rvs(scale=self.cm_duration_mean_ws2)
        self.lifetime = expon.rvs(scale=1/self.failure_rate)
        self.WS2_age = 0
        self.current_rul = self.lifetime
        return cm_duration

    def reset(self):
        self.hammer_degradation = np.zeros(self.n)
        self.production_pace = 'T1'
        self.time = 0
        self.last_pm_time = 0
        self.last_cm_time = 0
        self.total_replaced_hammers = 0
        self.unmet_demand_during_m = 0
        self.current_Pt = self.c1 * max(0, norm.rvs(loc=1.0, scale=0.1)) * 20
        self.current_dt = norm.rvs(loc=self.demand_mean, scale=self.demand_std)
        self.lifetime = expon.rvs(scale=1/self.failure_rate)
        self.current_rul = self.lifetime
        self.current_state_Pt, self.current_state_bt, self.current_state_dt = self.get_state(self.current_Pt, self.current_bt, self.current_dt)

        return self.current_state_Pt, self.current_state_bt, self.current_state_dt


    def step(self, action):
        reward = 0
        done = False

        self.first_ws_stopped = False
        self.second_ws_stopped = False
        time_before_m = self.time
        Pt_initial = self.current_Pt
        dt_initial = self.current_dt
        bt_initial = self.current_bt
        lifetime_initial = self.lifetime
        rul_initial = self.current_rul
        Pt_state_initial = self.current_state_Pt
        bt_state_initial = self.current_state_bt
        dt_state_initial = self.current_state_dt
        age_before_m = self.WS2_age
        hammer_degradation_initial = self.hammer_degradation.copy()
        production_pace_initial = self.production_pace

        ws2_maintenance_time = 0
        ws1_maintenance_time = 0


        if self.current_state_Pt == 3:
            cm_duration_ws1, replacement_cost = self.cm_perform_ws1()
            reward -= self.cf + self.ci + replacement_cost
            self.current_Pt = 0
            cm_duration_ws2 = 0
            if self.current_bt == 0:
                  self.current_dt = 0
                  self.second_ws_stopped = True
                  if self.current_rul <= 0:
                    cm_duration_ws2 = self.cm_perform_ws2()
            self.WS2_age += max(cm_duration_ws1, cm_duration_ws2)


            self.first_ws_stopped = True
            Pt_during_m = self.current_Pt
            bt_during_m = self.current_bt
            dt_during_m = self.current_dt

        elif self.time > 0 and self.current_bt <= 0:
            maintenance_duration, replacement_cost = self.pm_perform_ws1()
            reward -= self.ci + replacement_cost
            self.current_Pt = 0
            cm_duration_ws2 = 0
            if self.current_rul <= 0:
                cm_duration_ws2 = self.cm_perform_ws2()

            self.WS2_age += max(maintenance_duration, cm_duration_ws2)
            self.current_dt = 0
            self.second_ws_stopped = True
            self.first_ws_stopped = True
            Pt_during_m = self.current_Pt
            bt_during_m = self.current_bt
            dt_during_m = self.current_dt

        elif self.time > 0 and self.current_bt > self.buffer_capacity:
            maintenance_duration, replacement_cost = self.pm_perform_ws1()
            reward -= self.ci + replacement_cost
            self.current_Pt = 0
            cm_duration_ws2 = 0
            self.WS2_age += max(cm_duration_ws2, maintenance_duration)

            self.first_ws_stopped = True
            Pt_during_m = self.current_Pt
            bt_during_m = self.current_bt
            dt_during_m = self.current_dt

        elif self.current_rul <= 0:
            cm_duration = self.cm_perform_ws2()
            ws2_maintenance_time = cm_duration
            maintenance_duration, replacement_cost = self.pm_perform_ws1()
            reward -= self.ci + replacement_cost
            ws1_maintenance_time = maintenance_duration

            self.current_dt = 0
            self.current_Pt = 0
            max_maintenance_time = max(ws1_maintenance_time, ws2_maintenance_time)
            self.WS2_age += max_maintenance_time

            self.first_ws_stopped = True
            self.second_ws_stopped = True
            Pt_during_m = self.current_Pt
            bt_during_m = self.current_bt
            dt_during_m = self.current_dt

        elif self.time > 0 and int(self.time) % 24 == 0:
            if self.current_rul <= 0:
                cm_duration = self.cm_perform_ws2()
                ws2_maintenance_time = cm_duration
            else:

                ws2_maintenance_time = self.pm_duration_ws2

            maintenance_duration, replacement_cost = self.pm_perform_ws1()
            reward -= self.ci + replacement_cost
            ws1_maintenance_time = maintenance_duration

            self.current_dt = 0
            self.current_Pt = 0
            max_maintenance_time = max(ws1_maintenance_time, ws2_maintenance_time)
            self.WS2_age += max_maintenance_time

            self.first_ws_stopped = True
            self.second_ws_stopped = True
            Pt_during_m = self.current_Pt
            bt_during_m = self.current_bt
            dt_during_m = self.current_dt

        elif action == 1:
            last_num_defective_hammers = np.sum(self.hammer_degradation >= 0.2)
            maintenance_duration, replacement_cost = self.pm_perform_ws1_action1()
            reward -= self.ci + replacement_cost
            self.current_Pt = 0
            cm_duration_ws2 = 0
            if self.time > 0 and self.current_bt <= 0:
                  self.current_dt = 0
                  self.second_ws_stopped = True
                  if self.current_rul <= 0:
                      cm_duration_ws2 = self.cm_perform_ws2()
            self.WS2_age += max(cm_duration_ws2, maintenance_duration)

            self.first_ws_stopped = True
            Pt_during_m = self.current_Pt
            bt_during_m = self.current_bt
            dt_during_m = self.current_dt


        hammer_degradation_after_maintenance = self.hammer_degradation.copy()
        time_after_m = self.time
        age_after_m = self.WS2_age


        self.update_hammer_degradation()
        self.time += 1
        self.WS2_age += 1
        self.current_Pt = self.get_production_rate()
        self.current_dt = self.get_demand()
        self.current_bt = self.get_buffer_level(self.current_Pt, self.current_bt, self.current_dt)
        self.current_rul = self.get_rul()
        self.current_state_Pt, self.current_state_bt, self.current_state_dt = self.get_state(self.current_Pt, self.current_bt, self.current_dt)


        unmet_demand = self.get_unmet_demand(self.current_Pt, self.current_bt, self.current_dt)
        self.production_pace = self.get_production_pace(self.current_bt)
        reward -= self.cu * unmet_demand + self.cs * self.current_bt

        done = self.time >= 1000

        '''print(f"""
*** Inspection and Maintenance Times:
    Time Before Maintenance(valid if it's in a maintenance state): {time_before_m}
    Time After Maintenance(valid if it's in a maintenance state): {time_after_m}
    Inspection Time At the End: {self.time}
    Action: {action}
    Reward: {reward}


*** Initial Values:
    Production Rate (Pt): {Pt_initial}
    Demand (dt): {dt_initial}
    Buffer level (bt): {bt_initial}
    State -> Pt_state: {Pt_state_initial}, bt_state: {bt_state_initial}
    Hammer Degradation (Initial): {hammer_degradation_initial}
    production pace: {production_pace_initial}
""")

        if self.first_ws_stopped:
              print(f"""
*** During Maintenance:
    Production Rate (Pt): {Pt_during_m}
    Demand (dt): {dt_during_m}
    Buffer level (bt): {bt_during_m}
""")

        print(f"""
*** After 1 step:
    Production Rate (Pt): {self.current_Pt}
    Demand (dt): {self.current_dt}
    Buffer level (bt): {self.current_bt}
    State -> Pt_state: {self.current_state_Pt}, bt_state: {self.current_state_bt}, dt_state: {self.current_state_dt}
    Total Replaced Hammers: {self.last_num_defective_hammers}
    Hammer Degradation (After Maintenance): {hammer_degradation_after_maintenance}
    Hammer Degradation (After 1 step): {self.hammer_degradation}
    production pace: {self.production_pace}
    Unmet Demand: {unmet_demand}
""")

        print(f"""
*** next state: (Pt, bt, dt):{self.current_state_Pt, self.current_state_bt, self.current_state_dt}

""")
        print("-" * 150)'''

        return self.current_state_Pt, self.current_state_bt, self.current_state_dt, reward, done

